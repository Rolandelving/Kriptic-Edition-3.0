<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Quiz Solver - Ace Every Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            color: #ffffff;
            overflow-x: hidden;
            min-height: 100vh;
        }

        :root {
            --primary: #4169e1;
            --secondary: #9d4edd;
            --accent: #00d9ff;
        }

        /* Starfield Canvas */
        #starfield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Nebula Background */
        .nebula-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse 1000px 800px at 15% 30%, rgba(65, 105, 225, 0.15) 0%, transparent 60%),
                radial-gradient(ellipse 800px 1000px at 85% 70%, rgba(157, 78, 221, 0.12) 0%, transparent 60%),
                radial-gradient(ellipse 900px 900px at 50% 50%, rgba(0, 217, 255, 0.08) 0%, transparent 70%);
            z-index: 2;
            pointer-events: none;
            animation: nebulaPulse 20s ease-in-out infinite;
        }

        @keyframes nebulaPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Main Content */
        .content {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem 2rem;
        }

        /* Header */
        .header-section {
            text-align: center;
            margin-bottom: 4rem;
        }

        .logo {
            font-size: clamp(3rem, 8vw, 6rem);
            font-weight: 700;
            letter-spacing: 0.1em;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            animation: cosmicShift 8s ease infinite, logoFloat 4s ease-in-out infinite;
            text-shadow: 0 0 60px var(--primary);
            filter: drop-shadow(0 0 20px var(--primary));
        }

        @keyframes logoFloat {
            0%, 100% { transform: translateY(0px) scale(1); }
            50% { transform: translateY(-15px) scale(1.02); }
        }

        @keyframes cosmicShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tagline {
            font-size: clamp(1.1rem, 2.5vw, 1.5rem);
            color: rgba(255, 255, 255, 0.8);
            font-weight: 300;
            letter-spacing: 0.3em;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            color: var(--accent);
            font-weight: 300;
            letter-spacing: 0.2em;
        }

        /* Feature Cards */
        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            max-width: 1200px;
            width: 100%;
            margin-bottom: 3rem;
        }

        .feature-card {
            position: relative;
            padding: 3rem 2.5rem;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            backdrop-filter: blur(20px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            animation: cardFloat 6s ease-in-out infinite;
        }

        @keyframes cardFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .feature-card:nth-child(1) { animation-delay: 0s; }
        .feature-card:nth-child(2) { animation-delay: 0.5s; }
        .feature-card:nth-child(3) { animation-delay: 1s; }

        .feature-card::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 20px;
            padding: 2px;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.4s;
        }

        .feature-card:hover::before {
            opacity: 1;
        }

        .feature-card:hover {
            transform: translateY(-12px);
            background: rgba(0, 0, 0, 0.9);
            box-shadow: 0 25px 70px rgba(65, 105, 225, 0.3);
        }

        .feature-icon {
            font-size: 4rem;
            margin-bottom: 2rem;
            filter: drop-shadow(0 0 15px var(--primary));
        }

        .feature-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #ffffff;
        }

        .feature-desc {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
        }

        /* CTA Section */
        .cta-section {
            text-align: center;
            max-width: 800px;
            margin: 3rem auto;
        }

        .cta-title {
            font-size: clamp(1.8rem, 4vw, 2.5rem);
            color: var(--accent);
            margin-bottom: 1.5rem;
        }

        .code-container {
            position: relative;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--primary);
            border-radius: 16px;
            padding: 2.5rem;
            margin: 2rem 0;
            max-width: 100%;
            overflow-x: auto;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .code-title {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .copy-btn {
            padding: 0.5rem 1.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px var(--primary);
        }

        .code-block {
            background: rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #00ff88;
            white-space: pre;
            overflow-x: auto;
            text-align: left;
        }

        .steps-list {
            text-align: left;
            max-width: 600px;
            margin: 2rem auto;
            background: rgba(0, 0, 0, 0.8);
            padding: 2.5rem;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .step {
            margin-bottom: 1.5rem;
            padding-left: 2rem;
            position: relative;
        }

        .step::before {
            content: '‚Üí';
            position: absolute;
            left: 0;
            color: var(--accent);
            font-size: 1.2rem;
        }

        .step-title {
            font-size: 1.1rem;
            color: var(--accent);
            margin-bottom: 0.5rem;
        }

        .step-desc {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Stats */
        .stats-container {
            display: flex;
            gap: 3rem;
            background: rgba(0, 0, 0, 0.85);
            padding: 2.5rem 3.5rem;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(30px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            margin-bottom: 4rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        @media (max-width: 768px) {
            .features-grid {
                grid-template-columns: 1fr;
            }

            .stats-container {
                flex-direction: column;
                gap: 1.5rem;
                padding: 1.5rem 2rem;
            }

            .code-block {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="starfield"></canvas>
    <div class="nebula-overlay"></div>

    <div class="content">
        <div class="header-section">
            <h1 class="logo">AI QUIZ SOLVER</h1>
            <p class="tagline">Powered by Claude Sonnet 4.5</p>
            <p class="subtitle">The Ultimate Quiz-Solving Assistant</p>
        </div>

        <div class="stats-container">
            <div class="stat-item">
                <div class="stat-value">‚ö°</div>
                <div class="stat-label">Lightning Fast</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">üéØ</div>
                <div class="stat-label">Highly Accurate</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">üåç</div>
                <div class="stat-label">Multi-Language</div>
            </div>
        </div>

        <div class="features-grid">
            <div class="feature-card">
                <div class="feature-icon">üß†</div>
                <h3 class="feature-title">Smart Detection</h3>
                <p class="feature-desc">Automatically detects all question types: text inputs, multiple choice, checkboxes, dropdowns, and more.</p>
            </div>

            <div class="feature-card">
                <div class="feature-icon">üåê</div>
                <h3 class="feature-title">Language Expert</h3>
                <p class="feature-desc">Specialized in Spanish, English, and Japanese with perfect verb conjugations and grammar rules.</p>
            </div>

            <div class="feature-card">
                <div class="feature-icon">‚ö°</div>
                <h3 class="feature-title">Parallel Processing</h3>
                <p class="feature-desc">Processes multiple questions simultaneously for blazing-fast results.</p>
            </div>
        </div>

        <div class="cta-section">
            <h2 class="cta-title">Get Started in 3 Easy Steps</h2>
            
            <div class="steps-list">
                <div class="step">
                    <div class="step-title">Copy the Script</div>
                    <div class="step-desc">Click the button below to copy the complete ready-to-use code (make sure you are on your own personal PC)</div>
                </div>
                <div class="step">
                    <div class="step-title">Open Console</div>
                    <div class="step-desc">Press F12 or Ctrl+Shift+J (Cmd+Option+J on Mac) to open browser console</div>
                </div>
                <div class="step">
                    <div class="step-title">Paste & Go</div>
                    <div class="step-desc">Paste the code and hit Enter - it will ask for your API key, then solve the quiz!</div>
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">
                    <span class="code-title">Ready-to-Use Quiz Solver</span>
                    <button class="copy-btn" onclick="copyCode()">üìã Copy Complete Code</button>
                </div>
                <pre class="code-block" id="codeBlock">// AI Quiz Solver - Claude Sonnet 4.5
// Replace YOUR_API_KEY and paste into browser console

(async () => {
  const API_KEY = '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'; // <-- PUT YOUR KEY HERE
  const MODEL = 'claude-sonnet-4-5-20250929';

  // User choice for verification mode
  const choice = prompt(`Choose verification mode: 

PLEASE REVIEW THEIR ANSWERS BEFORE SUBMITTING

Choose verification mode:

1 = Single AI (RECOMMENDED)
   ‚úì Faster (half the time)
   ‚úì Cheaper (half the API cost)
   ‚úì Usually accurate enough for quizzes
   ‚úó No verification step

2 = Dual AI Verification
   ‚úì Each answer checked twice
   ‚úì Flags disagreements between AIs
   ‚úó 2x slower (double API calls)
   ‚úó 2x more expensive
   ‚úó Same model = similar mistakes (not true fact-checking)

Enter 1 or 2:`);

  const ENABLE_VERIFICATION = choice === '2';

  if (ENABLE_VERIFICATION) {
    const confirm = window.confirm('Dual verification will use 2x API calls. This doubles your cost. Continue?');
    if (!confirm) {
      console.log('‚ùå Cancelled by user');
      return;
    }
  }

  const spanishRules = `
Spanish conjugation patterns:
- AR verbs: yo/-o, t√∫/-as, √©l/ella/usted/-a, nosotros/-amos, vosotros/-√°is, ellos/ustedes/-an
- ER verbs: yo/-o, t√∫/-es, √©l/ella/usted/-e, nosotros/-emos, vosotros/-√©is, ellos/ustedes/-en  
- IR verbs: yo/-o, t√∫/-es, √©l/ella/usted/-e, nosotros/-imos, vosotros/-√≠s, ellos/ustedes/-en

Common verbs:
- necesitar: necesito, necesitas, necesita, necesitamos, necesit√°is, necesitan
- mirar: miro, miras, mira, miramos, mir√°is, miran
- llevar: llevo, llevas, lleva, llevamos, llev√°is, llevan
- caminar: camino, caminas, camina, caminamos, camin√°is, caminan
- esperar: espero, esperas, espera, esperamos, esper√°is, esperan
- hablar: hablo, hablas, habla, hablamos, habl√°is, hablan`;

  async function callClaude(prompt) {
    const proxyUrl = 'https://corsproxy.io/?';
    const apiUrl = encodeURIComponent('https://api.anthropic.com/v1/messages');
    
    try {
      const response = await fetch(proxyUrl + apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': API_KEY,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: MODEL,
          max_tokens: 1024,
          messages: [{ role: 'user', content: prompt }]
        })
      });

      if (response.status === 401) {
        throw new Error('Invalid API key - check your key on line 5');
      }

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API Error ${response.status}: ${errorText.substring(0, 100)}`);
      }
      
      const data = await response.json();
      return data.content[0].text;
    } catch (error) {
      throw error;
    }
  }

  async function verifyAnswer(question, options, firstAnswer) {
    const prompt = `You are verifying another AI's answer to a quiz question.

Question: ${question}

${options ? `Options:\n${options}\n` : ''}
First AI's Answer: ${firstAnswer}

Task: Determine if the first AI's answer is correct. Respond with:
- If CORRECT: Just repeat the exact answer: "${firstAnswer}"
- If INCORRECT: Provide the correct answer in the same format

Respond with ONLY the answer, nothing else.`;

    return await callClaude(prompt);
  }

  function detectQuestions() {
    const questions = [];

    // Text inputs and textareas
    document.querySelectorAll('input[type="text"], textarea').forEach((el, i) => {
      let context = '';
      const parent = el.closest('li, tr, td, div, p') || el.parentElement;
      if (parent) {
        context = parent.innerText || parent.textContent || '';
      }
      
      if (context.length < 20) {
        const grandParent = parent?.parentElement;
        if (grandParent) {
          context = grandParent.innerText || grandParent.textContent || '';
        }
      }

      context = context.replace(/\s+/g, ' ').trim();
      
      const hasQuestionMark = context.includes('?') || context.includes('¬ø');
      const hasVerb = /\([a-z√°√©√≠√≥√∫√±]+\)/i.test(context);
      const hasBlank = /_+/.test(context) || context.includes('____');
      const isQuiz = /question|pregunta|complete|fill|blank|conjugate/i.test(context);
      
      if (context.length > 5 && (hasQuestionMark || hasVerb || hasBlank || isQuiz)) {
        questions.push({
          type: 'text',
          element: el,
          question: context.substring(0, 500),
          id: `text-${i}`
        });
      }
    });

    // Contenteditable
    document.querySelectorAll('[contenteditable="true"]').forEach((el, i) => {
      const container = el.closest('div, li, tr') || el.parentElement;
      const context = container ? (container.innerText || container.textContent || '') : '';
      if (context.length > 5) {
        questions.push({
          type: 'editable',
          element: el,
          question: context.substring(0, 500),
          id: `edit-${i}`
        });
      }
    });

    // Radio buttons
    const radioGroups = {};
    document.querySelectorAll('input[type="radio"]').forEach(r => {
      const name = r.name || 'unnamed';
      if (!radioGroups[name]) radioGroups[name] = [];
      
      let optionText = '';
      const currentTd = r.closest('td');
      if (currentTd) {
        const nextTd = currentTd.nextElementSibling;
        if (nextTd && nextTd.classList.contains('quia_standard')) {
          optionText = nextTd.textContent.trim();
        }
      }
      
      if (!optionText) {
        const label = document.querySelector(`label[for="${r.id}"]`);
        optionText = label ? label.textContent.trim() : r.parentElement?.textContent.trim() || '';
      }
      
      radioGroups[name].push({
        element: r,
        text: optionText,
        value: r.value
      });
    });

    Object.entries(radioGroups).forEach(([name, radios], i) => {
      const firstRadio = radios[0].element;
      const listItem = firstRadio.closest('li');
      let questionText = '';
      
      if (listItem) {
        const clone = listItem.cloneNode(true);
        const table = clone.querySelector('table');
        if (table) table.remove();
        questionText = clone.textContent.trim();
      } else {
        const container = firstRadio.closest('div, form, fieldset, tr');
        questionText = container ? container.textContent.substring(0, 200).trim() : '';
      }
      
      questionText = questionText.replace(/\s+/g, ' ').trim();
      
      if (questionText.length > 5 && radios.some(o => o.text)) {
        questions.push({
          type: 'radio',
          question: questionText,
          options: radios,
          id: `radio-${i}`
        });
      }
    });

    // Checkboxes - multi-select
    const checkboxGroups = {};
    document.querySelectorAll('input[type="checkbox"]').forEach((el) => {
      const container = el.closest('li, tr, td, div');
      let groupKey = 'single';
      
      const listItem = el.closest('li');
      if (listItem) {
        const clone = listItem.cloneNode(true);
        const table = clone.querySelector('table');
        if (table) {
          table.remove();
          groupKey = clone.textContent.trim().substring(0, 100);
        }
      }
      
      if (!checkboxGroups[groupKey]) {
        checkboxGroups[groupKey] = {
          question: groupKey,
          checkboxes: []
        };
      }
      
      let optionText = '';
      const currentTd = el.closest('td');
      if (currentTd) {
        const nextTd = currentTd.nextElementSibling;
        if (nextTd && (nextTd.classList.contains('quia_standard') || nextTd.classList.contains('multianswertext'))) {
          optionText = nextTd.textContent.trim();
        }
      }
      
      if (!optionText) {
        const label = document.querySelector(`label[for="${el.id}"]`);
        optionText = label ? label.textContent.trim() : el.parentElement?.textContent.trim() || '';
      }
      
      checkboxGroups[groupKey].checkboxes.push({
        element: el,
        text: optionText
      });
    });

    Object.entries(checkboxGroups).forEach(([key, group], i) => {
      if (group.checkboxes.length === 0) return;
      
      if (group.checkboxes.length > 1 && key !== 'single') {
        questions.push({
          type: 'multiselect',
          question: group.question,
          options: group.checkboxes,
          id: `multiselect-${i}`
        });
      } else {
        group.checkboxes.forEach((cb, j) => {
          const container = cb.element.closest('div, li, form, tr, td') || cb.element.parentElement;
          const context = container ? (container.innerText || container.textContent || '') : '';
          
          if (context.length > 5) {
            questions.push({
              type: 'checkbox',
              element: cb.element,
              question: context.substring(0, 500),
              optionText: cb.text,
              id: `check-${i}-${j}`
            });
          }
        });
      }
    });

    // Select dropdowns
    document.querySelectorAll('select').forEach((el, i) => {
      const container = el.closest('div, form, li, tr, td');
      const context = container ? (container.innerText || container.textContent || '') : '';
      const options = Array.from(el.options).map(o => o.text.trim()).filter(t => t);
      
      if (context.length > 5 && options.length > 0) {
        questions.push({
          type: 'select',
          element: el,
          question: context.substring(0, 500),
          options: options,
          id: `select-${i}`
        });
      }
    });

    return questions;
  }

  function buildPrompt(q) {
    let prompt = `You are an expert tutor with knowledge of history, geography, Spanish, and general academics. Answer this quiz question accurately.\n\n`;
    prompt += `Question: ${q.question}\n\n`;
    
    if (q.type === 'radio' || q.type === 'select') {
      const opts = q.type === 'radio' ? q.options : q.options.map((text, i) => ({ text, value: i }));
      prompt += `Options:\n`;
      opts.forEach((opt, i) => {
        const letter = String.fromCharCode(65 + i);
        const text = typeof opt === 'string' ? opt : opt.text;
        prompt += `${letter}) ${text}\n`;
      });
      prompt += `\nRespond with ONLY the letter (A, B, C, D, E, etc.) of the correct answer. Just the letter, nothing else.`;
    } else if (q.type === 'multiselect') {
      prompt += `Options (select ALL that apply):\n`;
      q.options.forEach((opt, i) => {
        const letter = String.fromCharCode(65 + i);
        prompt += `${letter}) ${opt.text}\n`;
      });
      prompt += `\nRespond with ONLY the letters of ALL correct answers separated by commas (e.g., "A,C,E" or "B,D"). Just the letters with commas, nothing else.`;
    } else if (q.type === 'checkbox') {
      const isTrue = q.optionText.toLowerCase().includes('true') || q.optionText.toLowerCase().includes('cierto');
      const isFalse = q.optionText.toLowerCase().includes('false') || q.optionText.toLowerCase().includes('falso');
      
      if (isTrue || isFalse) {
        prompt += `Is this statement TRUE or FALSE?\n`;
        prompt += `Respond with ONLY "YES" if the statement is TRUE, or "NO" if the statement is FALSE.`;
      } else {
        prompt += `Statement: ${q.optionText}\nRespond with ONLY "YES" if this is correct/true, or "NO" if incorrect/false.`;
      }
    } else {
      prompt += spanishRules;
      prompt += `\n\nInstructions:
- Find the verb in parentheses like (necesitar), (mirar)
- Identify the subject (yo, t√∫, √©l/ella/usted, nosotros, vosotros, ellos/ustedes)
- Conjugate correctly for that subject
- Respond with ONLY the conjugated verb, nothing else
- Examples: "necesitan" "mira" "llev√°is" "caminamos"`;
    }
    
    return prompt;
  }

  function getOptionsText(q) {
    if (q.type === 'radio') {
      return q.options.map((o, i) => `${String.fromCharCode(65 + i)}) ${o.text}`).join('\n');
    } else if (q.type === 'multiselect') {
      return q.options.map((o, i) => `${String.fromCharCode(65 + i)}) ${o.text}`).join('\n');
    } else if (q.type === 'select') {
      return q.options.map((o, i) => `${String.fromCharCode(65 + i)}) ${o}`).join('\n');
    }
    return null;
  }

  async function applyAnswer(q, answer) {
    const clean = answer.trim();

    if (q.type === 'text') {
      q.element.value = clean;
      q.element.dispatchEvent(new Event('input', { bubbles: true }));
      q.element.dispatchEvent(new Event('change', { bubbles: true }));
      q.element.dispatchEvent(new Event('blur', { bubbles: true }));
    }
    else if (q.type === 'editable') {
      q.element.textContent = clean;
      q.element.dispatchEvent(new Event('input', { bubbles: true }));
      q.element.dispatchEvent(new Event('blur', { bubbles: true }));
    }
    else if (q.type === 'radio') {
      const match = clean.toUpperCase().match(/^([A-Z])/);
      const idx = match ? match[0].charCodeAt(0) - 65 : -1;
      
      if (idx >= 0 && q.options[idx]) {
        q.options[idx].element.checked = true;
        q.options[idx].element.dispatchEvent(new Event('change', { bubbles: true }));
        q.options[idx].element.dispatchEvent(new Event('click', { bubbles: true }));
      }
    }
    else if (q.type === 'multiselect') {
      const letters = clean.toUpperCase().match(/[A-Z]/g) || [];
      
      letters.forEach(letter => {
        const idx = letter.charCodeAt(0) - 65;
        if (idx >= 0 && q.options[idx]) {
          q.options[idx].element.checked = true;
          q.options[idx].element.dispatchEvent(new Event('change', { bubbles: true }));
          q.options[idx].element.dispatchEvent(new Event('click', { bubbles: true }));
        }
      });
    }
    else if (q.type === 'checkbox') {
      q.element.checked = clean.toUpperCase().includes('YES');
      q.element.dispatchEvent(new Event('change', { bubbles: true }));
      q.element.dispatchEvent(new Event('click', { bubbles: true }));
    }
    else if (q.type === 'select') {
      const match = clean.toUpperCase().match(/^([A-Z])/);
      const idx = match ? match[0].charCodeAt(0) - 65 : -1;
      
      if (idx >= 0 && idx < q.element.options.length) {
        q.element.selectedIndex = idx;
        q.element.dispatchEvent(new Event('change', { bubbles: true }));
      }
    }
  }

  const AUTO_SUBMIT = false;
  const DELAY_MS = 500;

  console.log(`üéØ AI Quiz Solver ${ENABLE_VERIFICATION ? 'with Dual Verification' : '(Single AI)'} starting...\n`);
  
  const questions = detectQuestions();
  
  if (questions.length === 0) {
    console.log('‚ùå No questions found');
    return;
  }

  console.log(`‚úÖ Found ${questions.length} questions\n`);

  let success = 0, failed = 0, verified = 0, disagreements = 0;

  const batchSize = 2;
  for (let i = 0; i < questions.length; i += batchSize) {
    const batch = questions.slice(i, i + batchSize);
    
    await Promise.all(batch.map(async (q) => {
      try {
        const preview = q.question.length > 70 ? q.question.substring(0, 70) + '...' : q.question;
        console.log(`üìù ${preview}`);
        
        if (q.type === 'radio') {
          console.log(`   Options: ${q.options.map((o, i) => String.fromCharCode(65 + i) + ') ' + o.text).join(', ')}`);
        } else if (q.type === 'multiselect') {
          console.log(`   Options (select all): ${q.options.map((o, i) => String.fromCharCode(65 + i) + ') ' + o.text).join(', ')}`);
        }
        
        const answer1 = await callClaude(buildPrompt(q));
        console.log(`   ${ENABLE_VERIFICATION ? 'AI #1:' : 'Answer:'} ${answer1}`);
        
        let finalAnswer = answer1;
        
        if (ENABLE_VERIFICATION) {
          await new Promise(r => setTimeout(r, 300));
          const answer2 = await verifyAnswer(q.question, getOptionsText(q), answer1);
          console.log(`   AI #2: ${answer2}`);
          
          if (answer1.trim().toUpperCase() === answer2.trim().toUpperCase()) {
            console.log(`   ‚úì Both AIs agree`);
            verified++;
          } else {
            console.log(`   ‚ö†Ô∏è DISAGREEMENT - Using AI #2's answer`);
            disagreements++;
            finalAnswer = answer2;
          }
        }
        
        await applyAnswer(q, finalAnswer);
        
        success++;
        console.log(`‚úÖ Final: ${finalAnswer}\n`);
      } catch (error) {
        failed++;
        console.log(`‚ùå ${error.message}\n`);
      }
    }));
    
    if (i + batchSize < questions.length) {
      await new Promise(r => setTimeout(r, DELAY_MS));
    }
  }

  console.log('‚îÅ'.repeat(50));
  console.log(`\nüéâ DONE! ${success}/${questions.length} answered`);
  if (ENABLE_VERIFICATION) {
    console.log(`‚úì Verified: ${verified} agreements`);
    if (disagreements > 0) {
      console.log(`‚ö†Ô∏è Disagreements: ${disagreements} (used AI #2's answer)`);
    }
  }
  if (failed > 0) console.log(`‚ùå Failed: ${failed}`);
  
  if (AUTO_SUBMIT) {
    console.log('\nüì§ Auto-submitting...');
    await new Promise(r => setTimeout(r, 500));
    
    const submitBtn = document.querySelector('input[name="tag_submit_all_at_once"], button[type="submit"], input[type="submit"]');
    if (submitBtn) {
      submitBtn.click();
      console.log('‚úÖ Submitted successfully!');
    } else {
      console.log('‚ö†Ô∏è Submit button not found');
    }
  }
  
  console.log('\n‚îÅ'.repeat(50));
})();</pre>
            </div>
        </div>
    </div>

    <script>
        // Starfield Animation
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const stars = Array.from({ length: 200 }, () => ({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2,
            speed: Math.random() * 0.5
        }));

        function drawStars() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
                
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            
            requestAnimationFrame(drawStars);
        }
        drawStars();

        // Copy Code Function - Works even when Clipboard API is blocked
        const YOUR_SCRIPT = `// AI Quiz Solver - Claude Sonnet 4.5
// Replace YOUR_API_KEY and paste into browser console

(async () => {
  const API_KEY = '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'; // <-- PUT YOUR KEY HERE
  const MODEL = 'claude-sonnet-4-5-20250929';

  // User choice for verification mode
  const choice = prompt(`Choose verification mode: 

PLEASE REVIEW THEIR ANSWERS BEFORE SUBMITTING

Choose verification mode:

1 = Single AI (RECOMMENDED)
   ‚úì Faster (half the time)
   ‚úì Cheaper (half the API cost)
   ‚úì Usually accurate enough for quizzes
   ‚úó No verification step

2 = Dual AI Verification
   ‚úì Each answer checked twice
   ‚úì Flags disagreements between AIs
   ‚úó 2x slower (double API calls)
   ‚úó 2x more expensive
   ‚úó Same model = similar mistakes (not true fact-checking)

Enter 1 or 2:`);

  const ENABLE_VERIFICATION = choice === '2';

  if (ENABLE_VERIFICATION) {
    const confirm = window.confirm('Dual verification will use 2x API calls. This doubles your cost. Continue?');
    if (!confirm) {
      console.log('‚ùå Cancelled by user');
      return;
    }
  }

  const spanishRules = `
Spanish conjugation patterns:
- AR verbs: yo/-o, t√∫/-as, √©l/ella/usted/-a, nosotros/-amos, vosotros/-√°is, ellos/ustedes/-an
- ER verbs: yo/-o, t√∫/-es, √©l/ella/usted/-e, nosotros/-emos, vosotros/-√©is, ellos/ustedes/-en  
- IR verbs: yo/-o, t√∫/-es, √©l/ella/usted/-e, nosotros/-imos, vosotros/-√≠s, ellos/ustedes/-en

Common verbs:
- necesitar: necesito, necesitas, necesita, necesitamos, necesit√°is, necesitan
- mirar: miro, miras, mira, miramos, mir√°is, miran
- llevar: llevo, llevas, lleva, llevamos, llev√°is, llevan
- caminar: camino, caminas, camina, caminamos, camin√°is, caminan
- esperar: espero, esperas, espera, esperamos, esper√°is, esperan
- hablar: hablo, hablas, habla, hablamos, habl√°is, hablan`;

  async function callClaude(prompt) {
    const proxyUrl = 'https://corsproxy.io/?';
    const apiUrl = encodeURIComponent('https://api.anthropic.com/v1/messages');
    
    try {
      const response = await fetch(proxyUrl + apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': API_KEY,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: MODEL,
          max_tokens: 1024,
          messages: [{ role: 'user', content: prompt }]
        })
      });

      if (response.status === 401) {
        throw new Error('Invalid API key - check your key on line 5');
      }

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API Error ${response.status}: ${errorText.substring(0, 100)}`);
      }
      
      const data = await response.json();
      return data.content[0].text;
    } catch (error) {
      throw error;
    }
  }

  async function verifyAnswer(question, options, firstAnswer) {
    const prompt = `You are verifying another AI's answer to a quiz question.

Question: ${question}

${options ? `Options:\n${options}\n` : ''}
First AI's Answer: ${firstAnswer}

Task: Determine if the first AI's answer is correct. Respond with:
- If CORRECT: Just repeat the exact answer: "${firstAnswer}"
- If INCORRECT: Provide the correct answer in the same format

Respond with ONLY the answer, nothing else.`;

    return await callClaude(prompt);
  }

  function detectQuestions() {
    const questions = [];

    // Text inputs and textareas
    document.querySelectorAll('input[type="text"], textarea').forEach((el, i) => {
      let context = '';
      const parent = el.closest('li, tr, td, div, p') || el.parentElement;
      if (parent) {
        context = parent.innerText || parent.textContent || '';
      }
      
      if (context.length < 20) {
        const grandParent = parent?.parentElement;
        if (grandParent) {
          context = grandParent.innerText || grandParent.textContent || '';
        }
      }

      context = context.replace(/\s+/g, ' ').trim();
      
      const hasQuestionMark = context.includes('?') || context.includes('¬ø');
      const hasVerb = /\([a-z√°√©√≠√≥√∫√±]+\)/i.test(context);
      const hasBlank = /_+/.test(context) || context.includes('____');
      const isQuiz = /question|pregunta|complete|fill|blank|conjugate/i.test(context);
      
      if (context.length > 5 && (hasQuestionMark || hasVerb || hasBlank || isQuiz)) {
        questions.push({
          type: 'text',
          element: el,
          question: context.substring(0, 500),
          id: `text-${i}`
        });
      }
    });

    // Contenteditable
    document.querySelectorAll('[contenteditable="true"]').forEach((el, i) => {
      const container = el.closest('div, li, tr') || el.parentElement;
      const context = container ? (container.innerText || container.textContent || '') : '';
      if (context.length > 5) {
        questions.push({
          type: 'editable',
          element: el,
          question: context.substring(0, 500),
          id: `edit-${i}`
        });
      }
    });

    // Radio buttons
    const radioGroups = {};
    document.querySelectorAll('input[type="radio"]').forEach(r => {
      const name = r.name || 'unnamed';
      if (!radioGroups[name]) radioGroups[name] = [];
      
      let optionText = '';
      const currentTd = r.closest('td');
      if (currentTd) {
        const nextTd = currentTd.nextElementSibling;
        if (nextTd && nextTd.classList.contains('quia_standard')) {
          optionText = nextTd.textContent.trim();
        }
      }
      
      if (!optionText) {
        const label = document.querySelector(`label[for="${r.id}"]`);
        optionText = label ? label.textContent.trim() : r.parentElement?.textContent.trim() || '';
      }
      
      radioGroups[name].push({
        element: r,
        text: optionText,
        value: r.value
      });
    });

    Object.entries(radioGroups).forEach(([name, radios], i) => {
      const firstRadio = radios[0].element;
      const listItem = firstRadio.closest('li');
      let questionText = '';
      
      if (listItem) {
        const clone = listItem.cloneNode(true);
        const table = clone.querySelector('table');
        if (table) table.remove();
        questionText = clone.textContent.trim();
      } else {
        const container = firstRadio.closest('div, form, fieldset, tr');
        questionText = container ? container.textContent.substring(0, 200).trim() : '';
      }
      
      questionText = questionText.replace(/\s+/g, ' ').trim();
      
      if (questionText.length > 5 && radios.some(o => o.text)) {
        questions.push({
          type: 'radio',
          question: questionText,
          options: radios,
          id: `radio-${i}`
        });
      }
    });

    // Checkboxes - multi-select
    const checkboxGroups = {};
    document.querySelectorAll('input[type="checkbox"]').forEach((el) => {
      const container = el.closest('li, tr, td, div');
      let groupKey = 'single';
      
      const listItem = el.closest('li');
      if (listItem) {
        const clone = listItem.cloneNode(true);
        const table = clone.querySelector('table');
        if (table) {
          table.remove();
          groupKey = clone.textContent.trim().substring(0, 100);
        }
      }
      
      if (!checkboxGroups[groupKey]) {
        checkboxGroups[groupKey] = {
          question: groupKey,
          checkboxes: []
        };
      }
      
      let optionText = '';
      const currentTd = el.closest('td');
      if (currentTd) {
        const nextTd = currentTd.nextElementSibling;
        if (nextTd && (nextTd.classList.contains('quia_standard') || nextTd.classList.contains('multianswertext'))) {
          optionText = nextTd.textContent.trim();
        }
      }
      
      if (!optionText) {
        const label = document.querySelector(`label[for="${el.id}"]`);
        optionText = label ? label.textContent.trim() : el.parentElement?.textContent.trim() || '';
      }
      
      checkboxGroups[groupKey].checkboxes.push({
        element: el,
        text: optionText
      });
    });

    Object.entries(checkboxGroups).forEach(([key, group], i) => {
      if (group.checkboxes.length === 0) return;
      
      if (group.checkboxes.length > 1 && key !== 'single') {
        questions.push({
          type: 'multiselect',
          question: group.question,
          options: group.checkboxes,
          id: `multiselect-${i}`
        });
      } else {
        group.checkboxes.forEach((cb, j) => {
          const container = cb.element.closest('div, li, form, tr, td') || cb.element.parentElement;
          const context = container ? (container.innerText || container.textContent || '') : '';
          
          if (context.length > 5) {
            questions.push({
              type: 'checkbox',
              element: cb.element,
              question: context.substring(0, 500),
              optionText: cb.text,
              id: `check-${i}-${j}`
            });
          }
        });
      }
    });

    // Select dropdowns
    document.querySelectorAll('select').forEach((el, i) => {
      const container = el.closest('div, form, li, tr, td');
      const context = container ? (container.innerText || container.textContent || '') : '';
      const options = Array.from(el.options).map(o => o.text.trim()).filter(t => t);
      
      if (context.length > 5 && options.length > 0) {
        questions.push({
          type: 'select',
          element: el,
          question: context.substring(0, 500),
          options: options,
          id: `select-${i}`
        });
      }
    });

    return questions;
  }

  function buildPrompt(q) {
    let prompt = `You are an expert tutor with knowledge of history, geography, Spanish, and general academics. Answer this quiz question accurately.\n\n`;
    prompt += `Question: ${q.question}\n\n`;
    
    if (q.type === 'radio' || q.type === 'select') {
      const opts = q.type === 'radio' ? q.options : q.options.map((text, i) => ({ text, value: i }));
      prompt += `Options:\n`;
      opts.forEach((opt, i) => {
        const letter = String.fromCharCode(65 + i);
        const text = typeof opt === 'string' ? opt : opt.text;
        prompt += `${letter}) ${text}\n`;
      });
      prompt += `\nRespond with ONLY the letter (A, B, C, D, E, etc.) of the correct answer. Just the letter, nothing else.`;
    } else if (q.type === 'multiselect') {
      prompt += `Options (select ALL that apply):\n`;
      q.options.forEach((opt, i) => {
        const letter = String.fromCharCode(65 + i);
        prompt += `${letter}) ${opt.text}\n`;
      });
      prompt += `\nRespond with ONLY the letters of ALL correct answers separated by commas (e.g., "A,C,E" or "B,D"). Just the letters with commas, nothing else.`;
    } else if (q.type === 'checkbox') {
      const isTrue = q.optionText.toLowerCase().includes('true') || q.optionText.toLowerCase().includes('cierto');
      const isFalse = q.optionText.toLowerCase().includes('false') || q.optionText.toLowerCase().includes('falso');
      
      if (isTrue || isFalse) {
        prompt += `Is this statement TRUE or FALSE?\n`;
        prompt += `Respond with ONLY "YES" if the statement is TRUE, or "NO" if the statement is FALSE.`;
      } else {
        prompt += `Statement: ${q.optionText}\nRespond with ONLY "YES" if this is correct/true, or "NO" if incorrect/false.`;
      }
    } else {
      prompt += spanishRules;
      prompt += `\n\nInstructions:
- Find the verb in parentheses like (necesitar), (mirar)
- Identify the subject (yo, t√∫, √©l/ella/usted, nosotros, vosotros, ellos/ustedes)
- Conjugate correctly for that subject
- Respond with ONLY the conjugated verb, nothing else
- Examples: "necesitan" "mira" "llev√°is" "caminamos"`;
    }
    
    return prompt;
  }

  function getOptionsText(q) {
    if (q.type === 'radio') {
      return q.options.map((o, i) => `${String.fromCharCode(65 + i)}) ${o.text}`).join('\n');
    } else if (q.type === 'multiselect') {
      return q.options.map((o, i) => `${String.fromCharCode(65 + i)}) ${o.text}`).join('\n');
    } else if (q.type === 'select') {
      return q.options.map((o, i) => `${String.fromCharCode(65 + i)}) ${o}`).join('\n');
    }
    return null;
  }

  async function applyAnswer(q, answer) {
    const clean = answer.trim();

    if (q.type === 'text') {
      q.element.value = clean;
      q.element.dispatchEvent(new Event('input', { bubbles: true }));
      q.element.dispatchEvent(new Event('change', { bubbles: true }));
      q.element.dispatchEvent(new Event('blur', { bubbles: true }));
    }
    else if (q.type === 'editable') {
      q.element.textContent = clean;
      q.element.dispatchEvent(new Event('input', { bubbles: true }));
      q.element.dispatchEvent(new Event('blur', { bubbles: true }));
    }
    else if (q.type === 'radio') {
      const match = clean.toUpperCase().match(/^([A-Z])/);
      const idx = match ? match[0].charCodeAt(0) - 65 : -1;
      
      if (idx >= 0 && q.options[idx]) {
        q.options[idx].element.checked = true;
        q.options[idx].element.dispatchEvent(new Event('change', { bubbles: true }));
        q.options[idx].element.dispatchEvent(new Event('click', { bubbles: true }));
      }
    }
    else if (q.type === 'multiselect') {
      const letters = clean.toUpperCase().match(/[A-Z]/g) || [];
      
      letters.forEach(letter => {
        const idx = letter.charCodeAt(0) - 65;
        if (idx >= 0 && q.options[idx]) {
          q.options[idx].element.checked = true;
          q.options[idx].element.dispatchEvent(new Event('change', { bubbles: true }));
          q.options[idx].element.dispatchEvent(new Event('click', { bubbles: true }));
        }
      });
    }
    else if (q.type === 'checkbox') {
      q.element.checked = clean.toUpperCase().includes('YES');
      q.element.dispatchEvent(new Event('change', { bubbles: true }));
      q.element.dispatchEvent(new Event('click', { bubbles: true }));
    }
    else if (q.type === 'select') {
      const match = clean.toUpperCase().match(/^([A-Z])/);
      const idx = match ? match[0].charCodeAt(0) - 65 : -1;
      
      if (idx >= 0 && idx < q.element.options.length) {
        q.element.selectedIndex = idx;
        q.element.dispatchEvent(new Event('change', { bubbles: true }));
      }
    }
  }

  const AUTO_SUBMIT = false;
  const DELAY_MS = 500;

  console.log(`üéØ AI Quiz Solver ${ENABLE_VERIFICATION ? 'with Dual Verification' : '(Single AI)'} starting...\n`);
  
  const questions = detectQuestions();
  
  if (questions.length === 0) {
    console.log('‚ùå No questions found');
    return;
  }

  console.log(`‚úÖ Found ${questions.length} questions\n`);

  let success = 0, failed = 0, verified = 0, disagreements = 0;

  const batchSize = 2;
  for (let i = 0; i < questions.length; i += batchSize) {
    const batch = questions.slice(i, i + batchSize);
    
    await Promise.all(batch.map(async (q) => {
      try {
        const preview = q.question.length > 70 ? q.question.substring(0, 70) + '...' : q.question;
        console.log(`üìù ${preview}`);
        
        if (q.type === 'radio') {
          console.log(`   Options: ${q.options.map((o, i) => String.fromCharCode(65 + i) + ') ' + o.text).join(', ')}`);
        } else if (q.type === 'multiselect') {
          console.log(`   Options (select all): ${q.options.map((o, i) => String.fromCharCode(65 + i) + ') ' + o.text).join(', ')}`);
        }
        
        const answer1 = await callClaude(buildPrompt(q));
        console.log(`   ${ENABLE_VERIFICATION ? 'AI #1:' : 'Answer:'} ${answer1}`);
        
        let finalAnswer = answer1;
        
        if (ENABLE_VERIFICATION) {
          await new Promise(r => setTimeout(r, 300));
          const answer2 = await verifyAnswer(q.question, getOptionsText(q), answer1);
          console.log(`   AI #2: ${answer2}`);
          
          if (answer1.trim().toUpperCase() === answer2.trim().toUpperCase()) {
            console.log(`   ‚úì Both AIs agree`);
            verified++;
          } else {
            console.log(`   ‚ö†Ô∏è DISAGREEMENT - Using AI #2's answer`);
            disagreements++;
            finalAnswer = answer2;
          }
        }
        
        await applyAnswer(q, finalAnswer);
        
        success++;
        console.log(`‚úÖ Final: ${finalAnswer}\n`);
      } catch (error) {
        failed++;
        console.log(`‚ùå ${error.message}\n`);
      }
    }));
    
    if (i + batchSize < questions.length) {
      await new Promise(r => setTimeout(r, DELAY_MS));
    }
  }

  console.log('‚îÅ'.repeat(50));
  console.log(`\nüéâ DONE! ${success}/${questions.length} answered`);
  if (ENABLE_VERIFICATION) {
    console.log(`‚úì Verified: ${verified} agreements`);
    if (disagreements > 0) {
      console.log(`‚ö†Ô∏è Disagreements: ${disagreements} (used AI #2's answer)`);
    }
  }
  if (failed > 0) console.log(`‚ùå Failed: ${failed}`);
  
  if (AUTO_SUBMIT) {
    console.log('\nüì§ Auto-submitting...');
    await new Promise(r => setTimeout(r, 500));
    
    const submitBtn = document.querySelector('input[name="tag_submit_all_at_once"], button[type="submit"], input[type="submit"]');
    if (submitBtn) {
      submitBtn.click();
      console.log('‚úÖ Submitted successfully!');
    } else {
      console.log('‚ö†Ô∏è Submit button not found');
    }
  }
  
  console.log('\n‚îÅ'.repeat(50));
})();`;

        function copyCode() {
            const scriptText = String(YOUR_SCRIPT); // Ensure it's a string
            
            // Try modern Clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(scriptText).then(() => {
                    showCopySuccess();
                }).catch(() => {
                    fallbackCopy(scriptText);
                });
            } else {
                fallbackCopy(scriptText);
            }
        }

        function fallbackCopy(text) {
            // Fallback method for when Clipboard API is blocked
            const textarea = document.createElement('textarea');
            textarea.value = text || YOUR_SCRIPT;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showCopySuccess();
                } else {
                    alert('Copy failed. Please manually select and copy the code.');
                }
            } catch (err) {
                alert('Copy failed. Please manually select and copy the code.');
            }
            
            document.body.removeChild(textarea);
        }

        function showCopySuccess() {
            const btn = document.querySelector('.copy-btn');
            btn.textContent = '‚úÖ Copied!';
            setTimeout(() => btn.textContent = 'üìã Copy Complete Code', 2000);
        }
    </script>
</body>
</html>